# Пошаговый план разработки RTS в стиле Warcraft II

## 1. Предпроектная подготовка
1. Определить целевую платформу (ПК), язык и движок. Язык программирования: **Rust**.
2. Сформировать референсы: Warcraft II, C&C, Age of Empires (скорость игры, размер карт, плотность микроконтроля).
3. Зафиксировать vision в 1–2 страницах: «что за игра, для кого, чем отличается».
4. Определить MVP (играбельная версия): 2 фракции, 1 режим skirmish, 1–2 карты, базовая экономика и бой.

## 2. Геймдизайн-документация
1. Описать core loop: добыча ресурсов → строительство → армия → разведка/бой → победа.
2. Спроектировать экономику:
   - типы ресурсов (например: золото, дерево, еда);
   - источники ресурсов и скорость добычи;
   - лимиты населения.
3. Описать фракции:
   - юниты (рабочий, пехота, дальник, осадный, морской/воздушный при необходимости);
   - здания (главное здание, казармы, мастерские, оборона);
   - апгрейды (урон, броня, скорость, технологии).
4. Определить условия победы/поражения и длительность матча (например 15–30 минут).

## 3. Техническая архитектура
1. Выбрать архитектуру данных (Entity-Component, data-driven конфиги в JSON/YAML).
2. Реализовать карту:
   - тайловая сетка;
   - коллизии и непроходимые зоны;
   - слои (земля, декор, ресурсы).
3. Реализовать навигацию:
   - A* на тайлах;
   - групповое движение и обход препятствий;
   - простую анти-заторную логику.
4. Реализовать deterministic simulation (фиксированный тик) для будущего мультиплеера.

## 4. Базовый геймплей (MVP)
1. Управление:
   - выделение рамкой;
   - команды move/attack/harvest/build;
   - горячие клавиши и очереди действий.
2. Экономика:
   - цикл добычи ресурсов рабочими;
   - доставка в базу;
   - отображение запасов.
3. Строительство:
   - размещение зданий по сетке;
   - проверка валидности места;
   - прогресс строительства.
4. Боёвка:
   - радиус обзора и атаки;
   - урон, броня, типы целей;
   - простейший ИИ цели (приоритет ближайшего/угрожающего).

## 5. Искусственный интеллект
1. Реализовать AI-бота через state machine:
   - early game (рабочие, экономика);
   - mid game (армия, давление);
   - late game (массовый пуш/осада).
2. Добавить скрипты поведения по сложности (easy/normal/hard):
   - коэффициенты добычи;
   - частота атак;
   - качество микроконтроля.

## 6. Контент-пайплайн
1. Вынести баланс в конфиги (стоимость, время производства, статы).
2. Подготовить временные ассеты (placeholder art/sfx), затем заменить на финальные.
3. Настроить импорт/экспорт карт, редактор карт (внутренний или внешний формат).

## 7. UX и полировка
1. UI: миникарта, панель команд, очередь производства, подсказки.
2. QoL: группы юнитов (Ctrl+1..9), точки сбора, shift-очереди приказов.
3. Обратная связь: звуки приказов, эффекты попаданий, читаемые анимации.

## 8. Тестирование и баланс
1. Ввести автотесты на ключевую логику (экономика, бой, pathfinding).
2. Запустить плейтесты с логированием матчей.
3. Проводить баланс-патчи по метрикам:
   - winrate фракций;
   - средняя длительность матча;
   - частота использования юнитов/апгрейдов.

## 9. Мультиплеер (поэтапно)
1. Начать с lockstep/rollback подхода (для RTS чаще lockstep + deterministic sim).
2. Реализовать синхронизацию команд игроков и проверку рассинхрона.
3. Добавить lobby, reconnect, surrender, базовый anti-cheat контроль команд.

## 10. Релизный цикл
1. Версия Alpha: core loop + 1 карта + 1 бот.
2. Версия Beta: полный набор базовых юнитов/зданий, несколько карт, баланс-проход.
3. Release Candidate: стабилизация, оптимизация, исправление критичных багов.
4. Релиз + post-launch roadmap: новые карты, фракции, улучшения матчмейкинга.

---

## Текущая реализация (старт MVP)
1. Подготовлен каркас проекта на Rust с модулем симуляции (ресурсы, карта, фиксированный тик).
2. Добавлена OpenGL-ориентированная очередь рендера для placeholder-текстур.
3. Placeholder-текстуры зафиксированы как цветные квадраты:
   - рабочий — синий;
   - казарма — красный;
   - золотая шахта — жёлтый;
   - лес — зелёный.
4. Реализован headless-рендер очереди `OpenGlRenderQueue` в `FrameBuffer` с экспортом в `PPM` (`target/render_preview.ppm`).
5. Следующий шаг: подключить платформенный OpenGL backend и выводить тот же буфер/очередь в окно в реальном времени.
